#!/usr/bin/env python2.7

import json, os, os.path, argparse, glob, re, ast

parser = argparse.ArgumentParser(description='Generate JSON configuration file for SystemDataScope')
parser.add_argument('root_dir', type=str,
                    help='Root directory with collectd RRD databases, for example /tmp/collectd/Jolla')

args = parser.parse_args()

Root = args.root_dir
os.chdir(Root)


######################################################################################
#
# These maps are used to specify several parameters of the graphs
# 

Units = { "DEFAULT": "",
          "CPU": "%",
          "Battery/voltage": "V",
          "Battery/charge": "%",
          "Battery/capacity": "%",
          "Battery/current": "A",
          "Battery/energy": "Wh",
          "Battery/power_battery": "W",
          "Battery/temperature": "C",
          "Battery/timelow": "h",
          "Battery/timefull": "h",
          "Context/context_switch": "1/s",
          "Entropy/entropy": "bits",
          "Memory": "bytes",
          "Network/octets": "bytes/s",
          "NetworkTotal/octets": "B",
          "Network": "1/s",
          "NetworkTotal": "",
          "Processes/cputime": "%",
          "Processes/disk_ops": "1/s",
          "Processes/disk_octets": "bytes/s",
          "Processes/vm": "bytes",
          "Processes/data": "bytes",
          "Processes/code": "bytes",
          "Processes/rss": "bytes",
          "Processes/pagefaults": "1/s",
          "Processes/stacksize": "bytes",
          "Disk/io_time": "%",
          "Disk/ops": "1/s",
          "Disk/octets": "bytes/s",
          #"Disk/time": "1/s",
          "Storage": "bytes",
          "Uptime/uptime": "days",
          "CPUstate/cpusleep": "%",
          "Radio/Cellular": "%",
          "Radio/Internet": "%",
}

Formats = { "DEFAULT": "%5.2lf",
            "Battery/charge": "%3.1lf",
            "Battery/capacity": "%3.1lf",
            "Battery/temperature": "%3.1lf",
            "Battery/energy": "%3.2lf",
            "Battery/power_battery": "%3.2lf",
            "Battery/voltage": "%1.3lf%S",
            "Battery/current": "%1.0lf%S",
            "Context/context_switch": "%1.0lf%S",
            "Entropy/entropy": "%1.0lf%S",
            "Memory/Overview": "%4.0lf%S",
            "Memory": "%4.0lf%S",
            "Load": "%5.2lf",
            "Network/octets": "%6.0lf%S",
            "Network/packets": "%6.0lf%S",
            "Network": "%6.2lf%S",
            "Processes/code": "%5.1lf%S",
            "Processes/data": "%5.1lf%S",
            "Processes/rss": "%5.1lf%S",
            "Processes/stacksize": "%5.1lf%S",
            "Processes/vm": "%5.1lf%S",
            "Processes/cputime": "%5.3lf",
            "Processes/disk_ops": "%4.0lf%S",
            "Processes/disk_octets": "%4.0lf%S",
            "Processes": "%5.1lf",
            "Processes/Overview": "%5.1lf",
            "Disk": "%4.0lf%S",
            "Disk/merged": "%5.2lf",
            "Disk/io_time": "%5.1lf",
            "Disk/ops": "%5.2lf",
            "CPUstate/cpusleep": "%0.0lf",
            "CPU/Overview": "%6.0lf",
            "CPU": "%0.0lf",
            "Storage": "%6.1lf%S",
            "Radio/Cellular": "%4.0lf",
            "Radio/Internet": "%4.0lf",
            "Radio/Bluetooth": "%4.2lf",
}

Heads = { "DEFAULT": None,
          "CPU/Overview": 6,
          "Storage": 7,
          "Disk": 5,
          "Memory/Overview": 5,
          "Network": 7,
          "Load/load": 5,
          "Processes/Overview": 5,
          "Processes/cputime": 5,
          "Processes/count": 5,
          "Processes/pagefaults": 5,
          "Processes/disk_octets": 5,
          "Processes/disk_ops": 5,
          "Radio/Cellular": 4,
          "Radio/Internet": 4,
          "Radio/Bluetooth": 4,
}

Human = { "DEFAULT": None,
          "Battery/power_battery": "Battery power consumption",
          "Battery/timefull": "Battery: time to full",
          "Battery/timelow": "Battery: time to low",
          "Disk/io_time": "I/O time",
          "Disk/merged": "Merged operations",
          "Disk/octets": "Traffic",
          "Disk/ops": "Operations",
          "Disk/time": "Average time per operation",
          "Network/octets": "Traffic",
          "Processes/cputime": "CPU time",
          "Processes/stacksize": "Stack size",
          "Processes/vm": "Virtual memory",
          "Processes/data": "Data size",
          "Processes/code": "Code size",
          "Processes/rss": "Resident segment size",
          "Processes/pagefaults": "Page faults",
          "Processes/disk_ops": "Disk operations",
          "Processes/disk_octets": "Disk traffic",
          "Processes/count": "# processes",
          "Radio/Cellular": "Cellular signal strength",
          "Radio/Internet": "Internet signal strength",
          "Radio/Bluetooth": "Bluetooth activity",
}

######################################################################################
## Helper classes

######################################################################################
# Colors

class ColorSingle:
    def __init__(self, color, color_opa):
        self.color = color
        self.color_opa = color_opa

    def set_number_of_lines(self, n):
        # noop
        self.n = n

    def get_color(self, i, opacity = 1.0):
        if opacity > 0.9: return self.color
        return self.color_opa
    

class Colors:
    # internally stored as RGBA integers
    # Colorschemes from http://colorbrewer2.org/ , qualitative
    def __init__(self, last_transparent = False):
        self.colors = None
        self.n = None
        self.last_transparent = last_transparent

        self.colorschemes = {}
        for cbrewer in [ "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)'",
                         "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)','rgb(152,78,163)'",
                         "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)','rgb(152,78,163)','rgb(255,127,0)'",
                         "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)','rgb(152,78,163)','rgb(255,127,0)','rgb(255,255,51)'",
                         "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)','rgb(152,78,163)','rgb(255,127,0)','rgb(255,255,51)','rgb(166,86,40)'",
                         "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)','rgb(152,78,163)','rgb(255,127,0)','rgb(255,255,51)','rgb(166,86,40)','rgb(247,129,191)'",
                         "'rgb(228,26,28)','rgb(55,126,184)','rgb(77,175,74)','rgb(152,78,163)','rgb(255,127,0)','rgb(255,255,51)','rgb(166,86,40)','rgb(247,129,191)','rgb(153,153,153)'"
        ]:
            cbrewer = "[ " +  cbrewer.replace("'rgb(", "[" ).replace(")'", "]" ) + " ]"
            colors = ast.literal_eval( cbrewer )
            for i in colors: i.append(255)
            self.colorschemes[ len(colors) ] = colors
            
    def set_number_of_lines(self, n):
        self.n = n
        if self.last_transparent: k = n-1
        else: k = n

        if self.colorschemes.has_key(k):
            self.colors = self.colorschemes[k]
        elif k < min(self.colorschemes.keys()):
            self.colors = self.colorschemes[ min(self.colorschemes.keys()) ]
        else:
            self.colors = self.colorschemes[ max(self.colorschemes.keys()) ]

    def makestr(self, c, opacity):
        s = "#"
        for i in c[:-1]:
            s += ("%02X" % int(round(i)) )
        s += ("%02X" % int(round(c[-1]*opacity)) )
        return s

    def get_color(self, i, opacity=1.0):
        if i == 0: return self.makestr(self.colors[0], opacity)
        if self.last_transparent:
            if i >= self.n-1: return self.makestr([0,0,0,0], opacity)
            elif i == self.n-2: return self.makestr(self.colors[-1], opacity)
        else:
            if i >= self.n-1: return self.makestr(self.colors[-1], opacity)

        if self.last_transparent: nc = self.n-2
        else: nc = self.n-1

        dline = float(i) / float(nc)
        color0 = int( (len(self.colors) - 1) * dline )
        factor = (len(self.colors) - 1) * dline - color0

        c = []
        for i in range(len(self.colors[color0])):            
            c.append( (1-factor)*self.colors[color0][i] + factor*self.colors[color0+1][i] )
        return self.makestr(c, opacity)

### Useful color objects
    
cs = Colors( )
csTr = Colors( True )
csSingle = ColorSingle( "$COLOR_LINE_SINGLE$", "$COLOR_LINE_SINGLE_SUB$")

############################################################################################

# Helper function to print table heading
def makeheads(l):
    s = ''
    fmt = '%' + str(l) + 's'
    heads = ["Avr", "Min", "Max", "Last"]
    for i, t in enumerate(heads):
        s += 'COMMENT:"' + (fmt % t)
        if i == len(heads)-1: s += '\\r" '
        else: s += '" '
    return s

# Class for making multiline(-area) plots or stacks

class StackOrLines:
    def __init__(self, colors, Type, name, Title = None,
                 Unit = None, isStack = False, minmax = False,
                 SkipLegend = False, HeadSize = None,
                 t = "LINE",
                 extra_command = "" ):
        self.lines = []
        self.gt = t
        self.colors = colors
        self.isStack = isStack
        self.minmax = minmax
        self.fullname = Type + "/" + name
        self.SkipLegend = SkipLegend
        
        if Unit is None: self.u = getunit(self.fullname)
        else: self.u = Unit
        
        if HeadSize is None: self.HeadSize = gethead(self.fullname)
        else: self.HeadSize = HeadSize
        
        command_def = '-t " '
        if Title is not None: command_def += Title
        elif Human.has_key( self.fullname ): command_def += Human[ self.fullname ]
        else: command_def += Type + " " + name

        if len(self.u) > 0: command_def += ", " + self.u
        command_def += '"  '  + " " + defColors + " " + extra_command + " "

        self.command_def = command_def

    # def add(self, name, width, options, extra="", makeLine=False, var_name = "value"):
    #     self.lines.append( { "name": name,
    #                          "width": width,
    #                          "options": options,
    #                          "extra": extra,
    #                          "makeLine": makeLine,
    #                          "var_name": var_name,
    #     } )
        
    def add(self, name, g, width="$LINE_WIDTH_PRIMARY$", makeLine=False, var_name = "value", Format = None, scale_data = None):
        if Format is None: Format = getf( self.fullname + "/" + name )
        self.lines.append( { "name": name,
                             "g": g,
                             "width": width,
                             "makeLine": makeLine,
                             "var_name": var_name,
                             "format": Format,
                             "scale_data": scale_data,
        } )
        
    def compose(self):
        command_def = self.command_def
        files = []

        # make all defs
        for i in self.lines:
            if i["scale_data"] is None: scale = False
            else: scale = True
        
            if i["g"] not in files:
                files.append( i["g"] )

            vd = i["name"]
            if scale: vd += "_data"

            command_def += "DEF:" + vd + "=" + i["g"] + ":" + i["var_name"] + ":AVERAGE "
            if self.minmax or not self.SkipLegend:
                command_def += "DEF:" + vd + "_min=" + i["g"] + ":" + i["var_name"] + ":MIN "
                command_def += "DEF:" + vd + "_max=" + i["g"] + ":" + i["var_name"] + ":MAX "

            if scale:
                command_def += "CDEF:" + i["name"] + "=" + vd + "," + i["scale_data"] + " "
                if self.minmax or not self.SkipLegend:
                    command_def += "CDEF:" + i["name"] + "_min=" + vd + "_min," + i["scale_data"] + " "
                    command_def += "CDEF:" + i["name"] + "_max=" + vd + "_max," + i["scale_data"] + " "
                    
            if self.minmax or not self.SkipLegend:    
                command_def += "CDEF:" + i["name"] + "_max_min_delta=" + i["name"] + "_max," + i["name"] + "_min,- "

        if not self.SkipLegend and self.HeadSize is not None:
            command_def += makeheads( self.HeadSize ) + " "
                
        s = command_def
        
        self.colors.set_number_of_lines(len(self.lines))
        if self.minmax:
            for idx, i in enumerate(self.lines):
                s += "LINE:" + i["name"] + "_min AREA:" + i["name"] + "_max_min_delta" + self.colors.get_color(idx, 0.5) + "::STACK "
                
        for idx, i in enumerate(self.lines):
            color = self.colors.get_color(idx) 
            s += self.gt
            if self.gt == "LINE": s += i["width"]
            s += ":" + i["name"] + color + ":"
            if not self.SkipLegend:
                if len(self.lines) > 1 or self.HeadSize is not None:
                    s += '"' + i["name"] + '\\l"'
                else:
                    s += '" \\l"'
                    
            if self.isStack and idx > 0 and not i["makeLine"]: s += ":STACK"
            s += " " #+ i["extra"] + " "

            if not self.SkipLegend:
                f = i["format"]
                name = i["name"]
                if self.HeadSize is None:
                    s += "COMMENT:\\u GPRINT:"+name+":AVERAGE:\"Avr " + f + "\" GPRINT:"+name+"_min:MIN:\"Min " + f + "\" GPRINT:"+name+"_max:MAX:\"Max " + f + "\" GPRINT:"+name+":LAST:\"Last " + f + "\\r\" "
                else:
                    s += "COMMENT:\\u GPRINT:"+name+":AVERAGE:\"" + f + "\" GPRINT:"+name+"_min:MIN:\"" + f + "\" GPRINT:"+name+"_max:MAX:\"" + f + "\" GPRINT:"+name+":LAST:\"" + f + "\\r\" "
                    
        gt = { "command": s,
               "files": files }
        plot = { "type": self.fullname }
        
        return gt, plot, self.fullname
    
######################################################################################
# Helper function for a single value plot
def maketypesplot(Type, name, g, Title = None, Format = None, Unit = None, minmax=True, SkipLegend = False,
                  var_name = "value", extra_command = "", scale_data = None):

    s = StackOrLines( csSingle, Type, name, Title=Title, Unit=Unit, SkipLegend=SkipLegend, minmax=minmax, extra_command=extra_command)
    s.add( name, g, var_name=var_name, Format=Format, scale_data=scale_data )

    return s.compose()


# used when more control is needed
class StackOrLinesOld:
    def __init__(self, col, isStack = False, minmax = False, t = "LINE"):
        self.lines = []
        self.gt = t
        self.colors = col
        self.isStack = isStack
        self.minmax = minmax

    def add(self, name, width, options, extra="", makeLine=False):
        self.lines.append( { "name": name,
                             "width": width,
                             "options": options,
                             "extra": extra,
                             "makeLine": makeLine } )
        
    def str(self):
        s = ""
        self.colors.set_number_of_lines(len(self.lines))
        if self.minmax:
            for idx, i in enumerate(self.lines):
                s += "LINE:" + i["name"] + "_min AREA:" + i["name"] + "_max_min_delta" + self.colors.get_color(idx, 0.5) + "::STACK "
                
        for idx, i in enumerate(self.lines):
            color = self.colors.get_color(idx) 
            s += self.gt
            if self.gt == "LINE": s += i["width"]
            s += ":" + i["name"] + color + ":" + i["options"]
            if self.isStack and idx > 0 and not i["makeLine"]: s += ":STACK"
            s += " " + i["extra"] + " "
            
        return s    


######################################################################################

def sorter(glob_arg, re_search = None, front = [], end = []):
    a = []
    for g in glob.glob( glob_arg ):
        if re_search is not None: m = re.search( re_search, g ).group(1)
        else: m = g
        added = False
        for k in [ [0,front], [10000,end] ] :
            if m in k[1]:
                a.append( [ k[0] + k[1].index( m ), g ] )
                added = True
        if not added:
            a.append( [ 5000, g ] )

    a.sort()
    r = []
    for i in a: r.append(i[1])
    return r
    

def getit(name, D):
    if name in D: return D[name]
    
    sname = name.split("/")
    if len(sname) > 1:
        s = ''
        for i in sname[:-1]: s += i + "/"        
        return getit( s[:-1], D )

    return D["DEFAULT"]

def getunit(name): return getit(name, Units)
def getf(name): return getit(name, Formats)
def gethead(name): return getit(name, Heads)

def gethuman(name):
    n = getit(name, Human)
    if n is None: return name
    return n
             
######################################################################################
# Start definition of types                

Config = {}

Config["variables"] = {
    "COLOR_BACKGROUND": "#00000000",
    "COLOR_CANVAS": "#00000000",
    "COLOR_FONT": "#000000FF",
    "COLOR_AXIS": "#000000FF",
    "COLOR_ARROW": "#000000FF",
    "COLOR_LINE_SINGLE": "#0000FFFF",
    "COLOR_LINE_SINGLE_SUB": "#0000FF80",

    "LINE_WIDTH_PRIMARY": "3",
    "LINE_WIDTH_SECONDARY": "1",
    }

Config["page"] = {
    
    "title": "Overview",
    "plots": [
    ]
}

Config["cover"] = [
    ]
    
Config["types"] = {}

defColors = "--color BACK$COLOR_BACKGROUND$ --color SHADEA$COLOR_BACKGROUND$ --color SHADEB$COLOR_BACKGROUND$ --color CANVAS$COLOR_CANVAS$  "
defColors += "--color FONT$COLOR_FONT$ --color AXIS$COLOR_AXIS$ --color ARROW$COLOR_ARROW$ "


######################################################################################
#
# DEFINITION OF GRAPHS
#
######################################################################################

######################################################################################
# CPU
if os.path.exists( "cpu" ):
    CpuPlots = { "subplots": { "title": "CPU details", "plots": [ { "type": "CPU/Overview" } ] } }

    # CPU overview
    
    s = StackOrLines( csTr, "CPU", "Overview", isStack = True, t = "AREA", extra_command = "--upper-limit 100 --lower-limit 0 --rigid" )
    cpustates = sorter( "cpu/*.rrd", "^cpu.*/.*-(.*).rrd",
                        ["interrupt", "softirq", "steal", "wait", "system"], 
                        ["user", "nice", "idle"] )
    
    for g in cpustates:
        name = re.search( "^cpu.*/.*-(.*).rrd", g ).group(1)
        s.add( name, g )

    gt, plot, fullname = s.compose()
    Config["types"][fullname] = gt
    CpuPlots["type"] = fullname

    # CPU overview : cover
    s = StackOrLines( csTr, "CPU", "Overview", Title="CPU", isStack = True, t = "AREA", extra_command = "--upper-limit 100 --lower-limit 0 --rigid", SkipLegend = True )

    for g in cpustates:
        name = re.search( "^cpu.*/.*-(.*).rrd", g ).group(1)
        s.add( name, g )

    gt, plot, fullname = s.compose()

    Config["types"]["CPU/Overview/cover"] = gt
    Config["cover"].append( "CPU/Overview/cover" )

    # Make CPU subplots
    cpustates.reverse()
    for g in cpustates:
        name = re.search( "^cpu.*/.*-(.*).rrd", g ).group(1)
        gt, plot, fullname = maketypesplot( "CPU", name, g, extra_command = "--upper-limit 100 --lower-limit 0 --rigid")

        Config["types"][fullname] = gt
        CpuPlots["subplots"]["plots"].append( plot )

    # Add all CPU plots
    Config["page"]["plots"].append( CpuPlots )


######################################################################################
# Battery 

if os.path.exists( "statefs_battery" ):
    BatteryPlots = { "subplots": { "title": "Battery details", "plots": [ ] } }

    Factors = { "DEFAULT": None,
                "timelow": "3600,/",
                "timefull": "3600,/",
                }

    Extra = { "DEFAULT": "",
              "capacity": "--upper-limit 100 --lower-limit 0 --rigid",
              "charge": "--upper-limit 100 --lower-limit 0 --rigid",
              "timelow": "--lower-limit 0",
              "timefull": "--lower-limit 0",
              "current": "HRULE:0$COLOR_LINE_SINGLE_SUB$",
              "power_battery": "HRULE:0$COLOR_LINE_SINGLE_SUB$",
              }

    for g in sorter( "statefs_battery/*.rrd" ):
        name = re.search( "^statefs_battery/(.*).rrd", g ).group(1)
        gt, plot, fullname = maketypesplot( "Battery", name, g,
                                            Title = getit("Battery/"+name, Human),
                                            extra_command = getit(name, Extra),
                                            scale_data=getit(name, Factors) )

        Config["types"][fullname] = gt
        BatteryPlots["subplots"]["plots"].append( plot )

    # Add all Battery plots
    BatteryPlots["type"] = "Battery/charge"
    Config["page"]["plots"].append( BatteryPlots )

    # Cover
    gt, plot, fullname = maketypesplot( "Battery", "charge",
                                        "statefs_battery/charge.rrd",
                                        Title = "Battery",
                                        extra_command = getit("capacity", Extra),
                                        SkipLegend = True )
    Config["types"]["Battery/charge/cover"] = gt
    Config["cover"].append( "Battery/charge/cover" )


elif os.path.exists( "battery-0" ):
    BatteryPlots = { "subplots": { "title": "Battery details", "plots": [ ] } }

    for g in sorter( "battery-0/*.rrd", "^battery.*/(.*).rrd" ):
        name = re.search( "^battery.*/(.*).rrd", g ).group(1)
        gt, plot, fullname = maketypesplot( "Battery", name, g )

        Config["types"][fullname] = gt
        BatteryPlots["subplots"]["plots"].append( plot )

    # Add all Battery plots
    BatteryPlots["type"] = "Battery/voltage"
    Config["page"]["plots"].append( BatteryPlots )

    # Cover
    gt, plot, fullname = maketypesplot( "Battery", "voltage", "battery-0/voltage.rrd", Title = "Battery", SkipLegend = True )
    Config["types"]["Battery/voltage/cover"] = gt
    Config["cover"].append( "Battery/voltage/cover" )


######################################################################################
# CPU states 

if os.path.exists( "cpusleep" ):
    Plots = { "subplots": { "title": "CPU states", "plots": [ ] } }

    ###################################################
    # CPU sleep needs some math
    g = "cpusleep/cpusleep.rrd"
    name = "cpusleep"
    gt, plot, fullname = maketypesplot( "CPUstate", name, g, Title="CPU sleep",
                                        extra_command='--upper-limit 100 --lower-limit 0 --rigid',
                                        scale_data = "10,/" )

    Plots["subplots"]["plots"].append( plot )

    Config["types"]["CPUstate/" + name] = gt
    Plots["type"] = fullname

    gt, plot, fullname = maketypesplot( "CPUstate", name, g, Title="CPU sleep",
                                        extra_command='--upper-limit 100 --lower-limit 0 --rigid',
                                        scale_data = "10,/", SkipLegend = True )

    Config["types"]["CPUstate/" + name + "/cover"] = gt
    Config["cover"].append( "CPUstate/" + name + "/cover" )

    # Add all CPU state plots
    Config["page"]["plots"].append( Plots )


######################################################################################
# Storage

if len( glob.glob( "df-*" ) ) > 0:
    Plots = { "subplots": { "title": "Storage details", "plots": [ ] } }

    for gd in sorter( "df-*", "^df-(.*)", ["root"] ):
        part_name = re.search( "^df-(.*)", gd ).group(1)

        # special treatment of tmp filesystem
        # remove it if you don't need it
        if part_name == "tmp":
            skip_free = True
        else:
            skip_free = False

        s = StackOrLines( cs, "Storage", part_name, isStack = True, t = "AREA",
                          extra_command = '--lower-limit 0' )

        for g in sorter( gd + "/*.rrd", "^df-.*/df_complex-(.*).rrd", front = ["used"], end=["free"] ):
            name = re.search( "^df-.*/df_complex-(.*).rrd", g ).group(1)
            if skip_free and name == "free": continue
            s.add( name, g )

        gt, plot, fullname = s.compose()
        
        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )
        if not Plots.has_key("type"): Plots["type"] = fullname


    # disk access rates
    DiskStats = { "time": [ "read", "write" ],
                  "octets": [ "read", "write" ],
                  "ops": [ "read", "write" ],
                  "merged": [ "read", "write" ],
                  "io_time": [ "io_time" ],
    }

    DiskScale = { "DEFAULT": None,
                  "io_time": "10,/", # from ms/s to %: 1ms / 1000ms * 100%
    }
    
    for gd in sorter( "disk-*" ):
        dname = re.search( "^disk-(.*)", gd ).group(1)
        if re.search( "(.*)p.*", dname ) is not None:
            continue # skip partitions

        for g in sorter( gd + "/disk_*.rrd" ):
            name = re.search( "^disk-.*/disk_(.*).rrd", g ).group(1)
            if name == "time":
                continue # skip this stat, not sure what it means [units]

            if name in DiskStats.keys():
                col = cs
                h = gethead( "Disk/" + name )
                if len( DiskStats[ name ] ) == 1:
                    col = csSingle
                    h = None
                
                s = StackOrLines( col, "Disk/" + dname, name, minmax=True,
                                  Title = dname + ': ' + gethuman("Disk/"+name),
                                  Unit = getunit("Disk/" + name),
                                  HeadSize = h,
                                  extra_command = "--lower-limit 0")

                for li, load_type in  enumerate(DiskStats[ name ]):
                    s.add( load_type, g, Format = getf("Disk/" + name), var_name = load_type, scale_data=getit( load_type, DiskScale ) )
                
                gt, plot, fullname = s.compose()
                
            else:
                gt, plot, fullname = maketypesplot( "Disk/" + dname, name, g, 
                                                    Title = dname + ': ' + getit("Disk/"+name, Human),
                                                    Format = getf("Disk/" + name),
                                                    Unit = getunit("Disk/" + name) )

            Config["types"][fullname] = gt
            Plots["subplots"]["plots"].append( plot )        

    Config["page"]["plots"].append( Plots )


######################################################################################
# Memory

if os.path.exists( "memory" ):
    Plots = { "subplots": { "title": "Memory details", "plots": [ ] } }

    # Memory overview
    s = StackOrLines( cs, "Memory", "Overview", isStack = True, t = "AREA", extra_command="--lower-limit 0"  )

    memory = sorter( "memory/*.rrd", "^memory/.*-(.*).rrd",
                     ["slab_unrecl", "slab_recl", "used", "buffered", "system"],
                     ["cached", "free"] )

    for g in memory:
        name = re.search( "^memory/.*-(.*).rrd", g ).group(1)
        s.add( name, g )

    gt, plot, fullname = s.compose()

    Config["types"][fullname] = gt
    Plots["type"] = fullname
    Plots["subplots"]["plots"].append( plot )

    # Memory overview: cover
    s = StackOrLines( cs, "Memory", "Overview", Title = "Memory, B", Unit = "", SkipLegend = True, isStack = True, t = "AREA", extra_command="--lower-limit 0"  )

    for g in memory:
        name = re.search( "^memory/.*-(.*).rrd", g ).group(1)
        s.add( name, g )

    gt, plot, fullname = s.compose()
    
    Config["types"]["Memory/overview/cover"] = gt
    Config["cover"].append( "Memory/overview/cover" )

    # detailed plots
    memory.reverse()
    for g in memory:
        name = re.search( "^memory/.*-(.*).rrd", g ).group(1)
        gt, plot, fullname = maketypesplot( "Memory", name, g )

        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )

    Config["page"]["plots"].append( Plots )

######################################################################################
if len( glob.glob("interface-*") ) > 0:

    Plots = { "subplots": { "title": "Network details", "plots": [ ] } }

    for CNet in sorter("interface-*/if_octets.rrd", "^interface-(.*)/if_octets.rrd", [], ["lo"]):
        intname = re.search( "^interface-(.*)/if_octets.rrd", CNet ).group(1)
            
        SubPlots = { "subplots": { "title": "Network details: " + intname, "plots": [ ] } }

        for g in glob.glob("interface-" + intname + "/if_*.rrd"):
            name = re.search( "^interface-.*/if_(.*).rrd", g ).group(1)
            fullname = "Network/" + intname + "/" + name
            f = getf("Network/" + name)
            u = getunit("Network/" + name)

            if name == "octets": hname = "traffic"
            else: hname = name

            command_def = '-t "Network ' + intname + ' ' + hname + ", " + u + '" --lower-limit 0 ' + defColors + makeheads(7)
            command_line = ""
            command_extra = ""
            files = [g]
            s = StackOrLinesOld( cs, minmax=True )
            for li, data_type in  enumerate([ "tx", "rx" ]):
                frm = f + u
                humandt = { "tx": "Outgoing", "rx": "Incoming" }[data_type]

                command_def += "DEF:" + data_type + "=" + g + ":" + data_type + ":AVERAGE "
                command_def += "DEF:" + data_type + "_min=" + g + ":" + data_type + ":MIN "
                command_def += "DEF:" + data_type + "_max=" + g + ":" + data_type + ":MAX "
                command_def += "CDEF:" + data_type + "_max_min_delta=" + data_type + "_max," + data_type + "_min,- "
                command_def += "VDEF:" + data_type + "_total=" + data_type + ",TOTAL "

                s.add( data_type, "$LINE_WIDTH_PRIMARY$", '"' + humandt + '\\l"',
                       "COMMENT:\\u GPRINT:"+data_type+":AVERAGE:\"" + f + "\" GPRINT:"+data_type+"_min:MIN:\"" + f +
                       "\" GPRINT:"+data_type+"_max:MAX:\"" + f + "\" GPRINT:"+data_type+":LAST:\"" + f + "\\r\" " + " " 
                )

                command_extra += 'GPRINT:' + data_type + '_total:"' + humandt + ' Total %8.0lf%s' + getunit("NetworkTotal/" + name) + '\\r" ' 

            command_line = s.str() + command_extra

            gt = { "command": command_def + command_line,
                   "files": files }
            plot = { "type": fullname }

            Config["types"][fullname] = gt
            SubPlots["subplots"]["plots"].append( plot )

        SubPlots["type"] = "Network/" + intname + "/octets"
        Plots["subplots"]["plots"].append( SubPlots )
        if not Plots.has_key("type"): Plots["type"]  = "Network/" + intname + "/octets"

    Config["page"]["plots"].append( Plots )


######################################################################################
if os.path.exists( "statefs_cellular" ):

    Plots = { "subplots": { "title": "Radio details", "plots": [ ] } }

    s = StackOrLines( cs, "Radio", "Cellular",
                      minmax = True,
                      extra_command = "--upper-limit 100 --lower-limit 0 --rigid" )
    for g in sorter( "statefs_cellular/signal_strength-*.rrd" ):
        name = re.search( "^statefs_cellular/signal_strength-(.*).rrd", g ).group(1)
        s.add( name, g )
    gt, plot, fullname = s.compose()

    Config["types"][fullname] = gt
    Plots["subplots"]["plots"].append( plot )
    Plots["type"] = fullname

    if os.path.exists( "statefs_internet" ):

        s = StackOrLines( cs, "Radio", "Internet",
                          minmax = True,
                          extra_command = "--upper-limit 100 --lower-limit 0 --rigid" )
        for g in sorter( "statefs_internet/signal_strength-*.rrd" ):
            name = re.search( "^statefs_internet/signal_strength-(.*).rrd", g ).group(1)
            s.add( name, g )
        gt, plot, fullname = s.compose()

        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )

    if os.path.exists( "statefs_bluetooth" ):

        s = StackOrLines( cs, "Radio", "Bluetooth",
                          minmax = False,
                          isStack = True,
                          t = "AREA" )
        for g in sorter( "statefs_bluetooth/*.rrd" ):
            name = re.search( "^statefs_bluetooth/bluetooth_(.*).rrd", g ).group(1)
            s.add( name, g )
        gt, plot, fullname = s.compose()

        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )

    Config["page"]["plots"].append( Plots )

    
######################################################################################
# Load
if os.path.exists( "load" ):
    Plots = { "subplots": { "title": "Load details", "plots": [ ] } }

    s = StackOrLines( cs, "Load", "load", Title="Load",
                      minmax=True, extra_command='--lower-limit 0' )

    for li, load_type in  enumerate([ "shortterm", "midterm", "longterm" ]):
        Type = "Load"
        name = load_type
        g = "load/load.rrd"

        s.add( name, g, var_name=name )

    gt, plot, fullname = s.compose()
    
    Config["types"][fullname] = gt
    Plots["type"] = fullname
    Plots["subplots"]["plots"].append( plot )
    #### Other Load related graphs

    g = "contextswitch/contextswitch.rrd"
    if os.path.exists(g):
        name = "context_switch"
        gt, plot, fullname = maketypesplot( "Context", name, g, "Context switch", extra_command='--lower-limit 0' )
        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )

    g = "entropy/entropy.rrd"
    if os.path.exists(g):
        name = "entropy"
        gt, plot, fullname = maketypesplot( "Entropy", name, g, "Entropy", extra_command='--lower-limit 0' )
        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )

    Config["page"]["plots"].append( Plots )


######################################################################################
# Processes
if os.path.exists( "processes" ):
    Plots = { "subplots": { "title": "Processes details", "plots": [ ] } }

    # Processes overview
    s = StackOrLines( cs, "Processes", "Overview", isStack = True, t = "AREA", extra_command = '--lower-limit 0' )
    processes = sorter( "processes/ps_state-*.rrd", "^processes/ps_state-(.*).rrd",
                        ["zombies", "paging", "blocked", "running"], ["stopped", "sleeping"] )
    for g in processes:
        name = re.search( "^processes/ps_state-(.*).rrd", g ).group(1)
        s.add( name, g )

    gt, plot, fullname = s.compose()

    Config["types"][fullname] = gt
    Plots["type"] = fullname
    Plots["subplots"]["plots"].append( plot )
    
    # detailed plots
    g = "processes/fork_rate.rrd"
    name = "fork_rate"
    gt, plot, fullname = maketypesplot( "Processes", name, g, "Fork rate, 1/s" )
    Config["types"][fullname] = gt
    Plots["subplots"]["plots"].append( plot )

    processes.reverse()
    for g in processes:
        name = re.search( "^processes/.*-(.*).rrd", g ).group(1)
        gt, plot, fullname = maketypesplot( "Processes", name, g )

        Config["types"][fullname] = gt
        Plots["subplots"]["plots"].append( plot )

    # detailed plots for selected processes

    ProcStats = { "cputime": [ "user", "syst" ],
                  "pagefaults": [ "minflt", "majflt" ],
                  "count": [ "processes", "threads" ],
                  "disk_octets": [ "read", "write" ],
                  "disk_ops": [ "read", "write" ],

    }

    ProcScale = { "DEFAULT": None,
                  "cputime": "10000,/", # from micros/s to %: 1us / 1000000us * 100%
    }
    for gp in sorter("processes-*"):
        procname = re.search("^processes-(.*)", gp).group(1)
        myplots = { "subplots": {"plots": [], "title": "Process " + procname } }

        for g in sorter("processes-" + procname + "/*rrd"):
            name = re.search( "^processes-" + procname + "/ps_(.*).rrd", g ).group(1)

            if name in ProcStats.keys():
                f = getf("Processes/" + name)
                u = getunit("Processes/" + name)

                s = StackOrLines( cs, "Processes/"+procname, name,
                                  Title = procname + ': ' + gethuman("Processes/"+name),
                                  HeadSize = gethead("Processes/"+name),
                                  extra_command = '--lower-limit 0',
                                  Unit = u,
                                  minmax=True )

                for li, load_type in  enumerate(ProcStats[ name ]):
                    s.add( load_type, g, var_name = load_type, Format=f, scale_data=getit(name,ProcScale)  )

                gt, plot, fullname = s.compose()

            else:
                gt, plot, fullname = maketypesplot( "Processes/" + procname, name, g, 
                                                    Title = procname + ': ' + getit("Processes/"+name, Human),
                                                    Format = getf("Processes/" + name),
                                                    Unit = getunit("Processes/" + name),
                                                    scale_data=getit(name,ProcScale) )

            Config["types"][fullname] = gt
            myplots["subplots"]["plots"].append( plot )
        myplots["type"] = "Processes/" + procname + "/cputime"
        Plots["subplots"]["plots"].append( myplots )

    Config["page"]["plots"].append( Plots )


###################################################
# Misc

Plots = { }


###################################################
# uptime 
g = "uptime/uptime.rrd"
if os.path.exists(g):    
    name = "uptime"
    gt, plot, fullname = maketypesplot( "Uptime", "uptime", g, Title="Uptime", scale_data="86400,/" )

    Config["types"][fullname] = gt
    Plots["type"] = fullname

    # Add all Misc plots: depends on uptime
    Config["page"]["plots"].append( Plots )



# Print resulting JSON configuration
print json.dumps(Config, indent=3)
